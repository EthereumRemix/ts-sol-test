"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
var _exportNames = {
  BzzNode: true
};
exports.BzzNode = void 0;

var _bzz = require("@erebos/bzz");

Object.keys(_bzz).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _bzz[key];
});

var _formData = _interopRequireDefault(require("form-data"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _tarStream = _interopRequireDefault(require("tar-stream"));

class BzzNode extends _bzz.Bzz {
  constructor(config) {
    var _config$fetch;

    const fetch = (_config$fetch = config.fetch) != null ? _config$fetch : _nodeFetch.default;
    super({ ...config,
      fetch
    });
  }

  async downloadDirectory(hash, options = {}) {
    const directoryData = {};

    const extract = _tarStream.default.extract();

    extract.on('entry', (header, stream, next) => {
      if (header.type === 'file') {
        const chunks = [];
        stream.on('data', chunk => {
          chunks.push(chunk);
        });
        stream.on('end', () => {
          directoryData[header.name] = {
            data: Buffer.concat(chunks),
            size: header.size
          };
          next();
        });
        stream.resume();
      } else {
        next();
      }
    });
    const res = await this.downloadTar(hash, options);
    return await new Promise(resolve => {
      extract.on('finish', () => {
        resolve(directoryData);
      });
      res.body.pipe(extract);
    });
  }

  async uploadDirectory(directory, options = {}) {
    var _options$headers;

    const form = new _formData.default();
    Object.keys(directory).forEach(key => {
      form.append(key, directory[key].data, {
        contentType: directory[key].contentType
      });
    });

    if (options.defaultPath != null) {
      const file = directory[options.defaultPath];

      if (file != null) {
        form.append('', file.data, {
          contentType: file.contentType
        });
      }
    }

    const headers = (_options$headers = options.headers) != null ? _options$headers : {};

    if (options.pin) {
      headers['x-swarm-pin'] = true;
    }

    options.headers = { ...headers,
      ...form.getHeaders()
    };
    return await this.uploadBody(form, options);
  }

}

exports.BzzNode = BzzNode;